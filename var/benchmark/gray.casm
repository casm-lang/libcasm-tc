//
//  Copyright (c) 2014-2016 CASM Organization
//  All rights reserved.
//
//  Developed by: Philipp Paulweber
//                Emmanuel Pescosta
//                https://github.com/casm-lang/libcasm-tc
//
//  This file is part of libcasm-tc.
//
//  libcasm-tc is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  libcasm-tc is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with libcasm-tc. If not, see <http://www.gnu.org/licenses/>.
//


CASM init foo

derived nrbits = 8

function inputnr: -> Integer
function input  : Integer -> Boolean
function output1 : Integer -> Boolean
function output2 : Integer -> Boolean


// gray = bin XOR (bin >> 1)
rule gray1(digit : Integer) = {
    if digit < nrbits-1 then
        output1(digit) := input(digit) xor input(digit+1)
    else
        output1(digit) := input(digit)
}

// idea: bit 0 cycles through 0,1,1,0; bit 1 cycles through 0,0,1,1,1,1,0,0 (double the cycle)
rule gray2(digit : Integer) = 
    case (inputnr/pow(2,digit)) % 4 of {
       0: output2(digit) := false
       1: output2(digit) := true
       2: output2(digit) := true
       3: output2(digit) := false
    }


rule foo = 
    if false then {
        program(self) := @main    
    } else     {
        inputnr := 0
        program(self) := @main2
    }

rule main =
{|
    call gray1(0)
    call gray2(0)
    program(self) := undef
|}

// all 4 bit numbers and their gray encoding
rule main2 = {
    if inputnr < pow(2,nrbits) then
    {|
        forall i in [0..7] do    {
            input(i) := asBoolean((inputnr / pow(2,i)) % 2)
        }
        forall i in [0..7] do    {
            call gray1(i)
            call gray2(i)
        }
        inputnr := inputnr + 1
        print dec(inputnr) + "=" + dec(output1(0)) + dec(output1(1)) + dec(output1(2)) + dec(output1(3)) + dec(output1(4)) + dec(output1(5))+ dec(output1(6)) + dec(output1(7)) + ", " 
                + dec(output2(0)) + dec(output2(1)) + dec(output2(2)) + dec(output2(3))+ dec(output2(4)) + dec(output2(5))+ dec(output2(6))+ dec(output2(7))
        assert output1(0) = output2(0)
        assert output1(1) = output2(1)
        assert output1(2) = output2(2)
        assert output1(3) = output2(3)
        assert output1(4) = output2(4)
        assert output1(5) = output2(5)
        assert output1(6) = output2(6)
        assert output1(7) = output2(7)
    |}
    else
        program(self) := undef
}
